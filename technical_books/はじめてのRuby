２章配列とハッシュ
モジュール
  共通のクラスを継承することなしに実装を共有するための仕組み

７章メソッド
  a.metod(1, "str")
  a::metod(1, "str")
  a = レシーバ
  metod = メソッド名
  (1, "str") = 引数
  上記のどちらでもメソッドを呼び出すことができる。
  レシーバが省略されている時はデフォルトのレシーバselfに対して呼ぶ

  引数を持たないメソッドのレシーバを省略するとローカル変数と見分けがつかなくなる場合がある。
  その場合はローカル変数が優先される。
  場合によってはselfでメソッドを明示してあげる。

  hoge = 1 #ローカル変数
  hoge #ローカル変数参照
  self.hoge #メソッド呼び出し

  組み込み関数
    putsやpがその代表例
    すべてのクラスはObjectクラスを通じてKernelモジュールをincludeしているから、任意のオブジェクトをレシーバとして
    これらのメソッドを呼び出せる。

  引数展開
    ※修飾により配列に格納された値を引数に展開できる
      array = [3,4,5]
      hoge(1,2,*array) #1,2,3,4,5で渡すのと同じ
      hoge(1,2,*array,6) #1,2,3,4,5,6で渡すのと同じ

      ※配列から引数への自動的な展開はできない
        def hoge(a,b)
          p [a,b]
        end
        kore = [1,2]
        x, y = kore #xが1,yが2
        hoge(kore) #引数が１つしかきてないエラーになる

  def式
    def prod(x,y) x*y end #1行にまとめるスタイル
    def prod x,y; x*y end #括弧を省略して１行にまとめるスタイル

    
  return
    返り値の式を省略して書いた場合はnilが返る

  多値の返却
    各々の式を評価した結果をまとめた配列で返す
      def hoge(a)
        return a,1,2,3
      end

  返り値に使い道が無いメソッドを実装する時は最後にnilを書く

  デフォルト値
    def hoge(a, b = 1)
    end
    bにデフォルト値を設定している

  ブロック引数とローカル引数
    a = "str"
    [1,2,3].each{|a| p a} #このaは上のaとは別物

８章オブジェクトとクラス
  複数のクラスを継承することはできない

  インスタンスメソッドの定義
    class Hoge
      def print(a)
        p a
      end
    end
    呼び出し方：hoge = Hoge.new
              hoge.print 1
    class式内部にdef式を書くと、そのメソッドはインスタンスメソッドになる
      Ekisuke.findみたいな

  クラスメソッドの定義
    class Hoge
      def Hoge.print(a)   ※self.printでもいける
        p a
      end
    end
    呼び出し方：Hoge.print 1
    このようにクラス名をつけてメソッドを定義すると、クラスメソッドになる。

  インスタンス化
    hoge = Hoge.new <=これをインスタンス化という
    インスタンス化する時にクラス内のinitializeが自動的に呼ばれる

    属性...attr_accessor等で設定してるやつ
    
  定数...クラスに属する変更不可能な値(外部からは修飾して参照できる)
        Hoge::METHODとか

  モジュール...
    インスタンス化できないクラスのようなもの
    Mix-inと名前空間の２つの役割がある
      Mix-in→制限された多重継承